/*
 ==============================================================================
 
 This file was auto-generated by the Introjucer!
 
 It contains the basic framework code for a JUCE plugin processor.
 
 ==============================================================================
 */

#ifndef PLUGINPROCESSOR_H_INCLUDED
#define PLUGINPROCESSOR_H_INCLUDED

#include "../JuceLibraryCode/JuceHeader.h"
#include "DrumSynthAudioSource.h"
class MyAudioSource : AudioSource
{
public:
    MyAudioSource(){
        formatManager.registerBasicFormats();
};
    ~MyAudioSource(){};
    void prepareToPlay (int /*samplesPerBlockExpected*/, double /*sampleRate*/) override
    {
    };
    
    void getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill) override
    {
        const int numInputChannels = fileBuffer.getNumChannels();
        const int numOutputChannels = bufferToFill.buffer->getNumChannels();
        
        int outputSamplesRemaining = bufferToFill.numSamples;
        int outputSamplesOffset = bufferToFill.startSample;
        
        while (outputSamplesRemaining > 0)
        {
            int bufferSamplesRemaining = fileBuffer.getNumSamples() - position;
            int samplesThisTime = jmin (outputSamplesRemaining, bufferSamplesRemaining);
            
            for (int channel = 0; channel < numOutputChannels; ++channel)
            {
                bufferToFill.buffer->copyFrom (channel,
                                               outputSamplesOffset,
                                               fileBuffer,
                                               channel % numInputChannels,
                                               position,
                                               samplesThisTime);
            }
            
            outputSamplesRemaining -= samplesThisTime;
            outputSamplesOffset += samplesThisTime;
            position += samplesThisTime;
            
            if (position == fileBuffer.getNumSamples())
                outputSamplesRemaining = 0;
        }
    }
    
    void releaseResources() override
    {
        fileBuffer.setSize (0, 0);
    }
    
    void setFiles(){
        
    }
    
    void playFromButton(int ID){
        File manualFileChoice[3];
        
        manualFileChoice[0] = "/Users/GeorgeDemner/Music/Logic/FYP_Drums_Session1_Shells/BassDrumFiles/Standard Hits/Drum Recording Session 1_BDrum100_128/In/Bass Drum In 6_6.wav";
        manualFileChoice[1] = "/Users/GeorgeDemner/Documents/UWE/Year 3/Final Year Project/FYP/TestSynthAUOrigin/Resources/WAVs/Snare Standard Hit 6/Up/Snare Down 6_6.wav";
        manualFileChoice[2] = "/Users/GeorgeDemner/Desktop/Hats Closed Shaft Close Mic 6_6.wav";
            
            
            ScopedPointer<AudioFormatReader> readers[3];
            for(int r=0; r<3; r++){
                readers[r] = formatManager.createReaderFor(manualFileChoice[r]);
            }
            
            if (readers[0] != nullptr)
            {
                fileBuffer.setSize (readers[0]->numChannels, readers[0]->lengthInSamples);      // [4]
                readers[0]->read (&fileBuffer,                                              // [5]
                               0,                                                        //  [5.1]
                               readers[0]->lengthInSamples,                                  //  [5.2]
                               0,                                                        //  [5.3]
                               true,                                                     //  [5.4]
                               true);                                                    //  [5.5]
                position = 0;                                                           // [6]
            }
            else
            {
                // handle the error that the file is 2 seconds or longer..
            }
        }
        
    private:
        AudioFormatManager formatManager;
        AudioSampleBuffer fileBuffer;
        int position;
    };
    
    class MySynthesiserVoice : SynthesiserVoice{
        
        
        
    };
    class Fyp_samplerPrototype2AudioProcessor  : public AudioProcessor
    {
    public:
        //==============================================================================
        Fyp_samplerPrototype2AudioProcessor();
        ~Fyp_samplerPrototype2AudioProcessor();
        
        //==============================================================================
        void prepareToPlay (double sampleRate, int samplesPerBlock) override;
        void releaseResources() override;
        
        void processBlock (AudioSampleBuffer&, MidiBuffer&) override;
        
        //==============================================================================
        AudioProcessorEditor* createEditor() override;
        bool hasEditor() const override;
        
        //==============================================================================
        const String getName() const override;
        
        const String getInputChannelName (int channelIndex) const override;
        const String getOutputChannelName (int channelIndex) const override;
        bool isInputChannelStereoPair (int index) const override;
        bool isOutputChannelStereoPair (int index) const override;
        
        bool acceptsMidi() const override;
        bool producesMidi() const override;
        bool silenceInProducesSilenceOut() const override;
        double getTailLengthSeconds() const override;
        
        //==============================================================================
        int getNumPrograms() override;
        int getCurrentProgram() override;
        void setCurrentProgram (int index) override;
        const String getProgramName (int index) override;
        void changeProgramName (int index, const String& newName) override;
        
        //==============================================================================
        void getStateInformation (MemoryBlock& destData) override;
        void setStateInformation (const void* data, int sizeInBytes) override;
        
        DrumSynthAudioSource kickAudioSource;

    private:
        AudioProcessorEditor* pEditor;
        //==============================================================================
        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Fyp_samplerPrototype2AudioProcessor)
    };
    
    
#endif  // PLUGINPROCESSOR_H_INCLUDED
